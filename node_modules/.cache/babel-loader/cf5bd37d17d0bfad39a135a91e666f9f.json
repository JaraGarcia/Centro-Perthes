{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*!\n * knox - auth\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar crypto = require('crypto'),\n  parse = require('url').parse;\n\n/**\n * Valid keys.\n */\n\nvar keys = ['acl', 'location', 'logging', 'notification', 'partNumber', 'policy', 'requestPayment', 'torrent', 'uploadId', 'uploads', 'versionId', 'versioning', 'versions', 'website'];\n\n/**\n * Return an \"Authorization\" header value with the given `options`\n * in the form of \"AWS <key>:<signature>\"\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction authorization(options) {\n  return 'AWS ' + options.key + ':' + sign(options);\n}\nmodule.exports = authorization;\nmodule.exports.authorization = authorization;\n\n/**\n * Simple HMAC-SHA1 Wrapper\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction hmacSha1(options) {\n  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64');\n}\nmodule.exports.hmacSha1 = hmacSha1;\n\n/**\n * Create a base64 sha1 HMAC for `options`. \n * \n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction sign(options) {\n  options.message = stringToSign(options);\n  return hmacSha1(options);\n}\nmodule.exports.sign = sign;\n\n/**\n * Create a base64 sha1 HMAC for `options`. \n *\n * Specifically to be used with S3 presigned URLs\n * \n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction signQuery(options) {\n  options.message = queryStringToSign(options);\n  return hmacSha1(options);\n}\nmodule.exports.signQuery = signQuery;\n\n/**\n * Return a string for sign() with the given `options`.\n *\n * Spec:\n * \n *    <verb>\\n\n *    <md5>\\n\n *    <content-type>\\n\n *    <date>\\n\n *    [headers\\n]\n *    <resource>\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction stringToSign(options) {\n  var headers = options.amazonHeaders || '';\n  if (headers) headers += '\\n';\n  var r = [options.verb, options.md5, options.contentType, options.date.toUTCString(), headers + options.resource];\n  return r.join('\\n');\n}\nmodule.exports.queryStringToSign = stringToSign;\n\n/**\n * Return a string for sign() with the given `options`, but is meant exclusively\n * for S3 presigned URLs\n *\n * Spec:\n * \n *    <date>\\n\n *    <resource>\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction queryStringToSign(options) {\n  return 'GET\\n\\n\\n' + options.date + '\\n' + options.resource;\n}\nmodule.exports.queryStringToSign = queryStringToSign;\n\n/**\n * Perform the following:\n *\n *  - ignore non-amazon headers\n *  - lowercase fields\n *  - sort lexicographically\n *  - trim whitespace between \":\"\n *  - join with newline\n *\n * @param {Object} headers\n * @return {String}\n * @api private\n */\n\nfunction canonicalizeHeaders(headers) {\n  var buf = [],\n    fields = Object.keys(headers);\n  for (var i = 0, len = fields.length; i < len; ++i) {\n    var field = fields[i],\n      val = headers[field],\n      field = field.toLowerCase();\n    if (0 !== field.indexOf('x-amz')) continue;\n    buf.push(field + ':' + val);\n  }\n  return buf.sort().join('\\n');\n}\nmodule.exports.canonicalizeHeaders = canonicalizeHeaders;\n\n/**\n * Perform the following:\n *\n *  - ignore non sub-resources\n *  - sort lexicographically\n *\n * @param {String} resource\n * @return {String}\n * @api private\n */\n\nfunction canonicalizeResource(resource) {\n  var url = parse(resource, true),\n    path = url.pathname,\n    buf = [];\n  Object.keys(url.query).forEach(function (key) {\n    if (!~keys.indexOf(key)) return;\n    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key]);\n    buf.push(key + val);\n  });\n  return path + (buf.length ? '?' + buf.sort().join('&') : '');\n}\nmodule.exports.canonicalizeResource = canonicalizeResource;","map":{"version":3,"names":["crypto","require","parse","keys","authorization","options","key","sign","module","exports","hmacSha1","createHmac","secret","update","message","digest","stringToSign","signQuery","queryStringToSign","headers","amazonHeaders","r","verb","md5","contentType","date","toUTCString","resource","join","canonicalizeHeaders","buf","fields","Object","i","len","length","field","val","toLowerCase","indexOf","push","sort","canonicalizeResource","url","path","pathname","query","forEach","encodeURIComponent"],"sources":["/Users/jaraga/CodeOp/perthesclinica/node_modules/aws-sign/index.js"],"sourcesContent":["\n/*!\n * knox - auth\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar crypto = require('crypto')\n  , parse = require('url').parse\n  ;\n\n/**\n * Valid keys.\n */\n\nvar keys = \n  [ 'acl'\n  , 'location'\n  , 'logging'\n  , 'notification'\n  , 'partNumber'\n  , 'policy'\n  , 'requestPayment'\n  , 'torrent'\n  , 'uploadId'\n  , 'uploads'\n  , 'versionId'\n  , 'versioning'\n  , 'versions'\n  , 'website'\n  ]\n\n/**\n * Return an \"Authorization\" header value with the given `options`\n * in the form of \"AWS <key>:<signature>\"\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction authorization (options) {\n  return 'AWS ' + options.key + ':' + sign(options)\n}\n\nmodule.exports = authorization\nmodule.exports.authorization = authorization\n\n/**\n * Simple HMAC-SHA1 Wrapper\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */ \n\nfunction hmacSha1 (options) {\n  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')\n}\n\nmodule.exports.hmacSha1 = hmacSha1\n\n/**\n * Create a base64 sha1 HMAC for `options`. \n * \n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction sign (options) {\n  options.message = stringToSign(options)\n  return hmacSha1(options)\n}\nmodule.exports.sign = sign\n\n/**\n * Create a base64 sha1 HMAC for `options`. \n *\n * Specifically to be used with S3 presigned URLs\n * \n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction signQuery (options) {\n  options.message = queryStringToSign(options)\n  return hmacSha1(options)\n}\nmodule.exports.signQuery= signQuery\n\n/**\n * Return a string for sign() with the given `options`.\n *\n * Spec:\n * \n *    <verb>\\n\n *    <md5>\\n\n *    <content-type>\\n\n *    <date>\\n\n *    [headers\\n]\n *    <resource>\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction stringToSign (options) {\n  var headers = options.amazonHeaders || ''\n  if (headers) headers += '\\n'\n  var r = \n    [ options.verb\n    , options.md5\n    , options.contentType\n    , options.date.toUTCString()\n    , headers + options.resource\n    ]\n  return r.join('\\n')\n}\nmodule.exports.queryStringToSign = stringToSign\n\n/**\n * Return a string for sign() with the given `options`, but is meant exclusively\n * for S3 presigned URLs\n *\n * Spec:\n * \n *    <date>\\n\n *    <resource>\n *\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction queryStringToSign (options){\n  return 'GET\\n\\n\\n' + options.date + '\\n' + options.resource\n}\nmodule.exports.queryStringToSign = queryStringToSign\n\n/**\n * Perform the following:\n *\n *  - ignore non-amazon headers\n *  - lowercase fields\n *  - sort lexicographically\n *  - trim whitespace between \":\"\n *  - join with newline\n *\n * @param {Object} headers\n * @return {String}\n * @api private\n */\n\nfunction canonicalizeHeaders (headers) {\n  var buf = []\n    , fields = Object.keys(headers)\n    ;\n  for (var i = 0, len = fields.length; i < len; ++i) {\n    var field = fields[i]\n      , val = headers[field]\n      , field = field.toLowerCase()\n      ;\n    if (0 !== field.indexOf('x-amz')) continue\n    buf.push(field + ':' + val)\n  }\n  return buf.sort().join('\\n')\n}\nmodule.exports.canonicalizeHeaders = canonicalizeHeaders\n\n/**\n * Perform the following:\n *\n *  - ignore non sub-resources\n *  - sort lexicographically\n *\n * @param {String} resource\n * @return {String}\n * @api private\n */\n\nfunction canonicalizeResource (resource) {\n  var url = parse(resource, true)\n    , path = url.pathname\n    , buf = []\n    ;\n\n  Object.keys(url.query).forEach(function(key){\n    if (!~keys.indexOf(key)) return\n    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])\n    buf.push(key + val)\n  })\n\n  return path + (buf.length ? '?' + buf.sort().join('&') : '')\n}\nmodule.exports.canonicalizeResource = canonicalizeResource\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}