{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n///--- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n///--- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data)) throw new TypeError('data must be a node Buffer');\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n  var self = this;\n  this.__defineGetter__('length', function () {\n    return self._len;\n  });\n  this.__defineGetter__('offset', function () {\n    return self._offset;\n  });\n  this.__defineGetter__('remain', function () {\n    return self._size - self._offset;\n  });\n  this.__defineGetter__('buffer', function () {\n    return self._buf.slice(self._offset);\n  });\n}\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1) return null;\n  var b = this._buf[this._offset] & 0xff;\n  if (!peek) this._offset += 1;\n  return b;\n};\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined) offset = this._offset;\n  if (offset >= this._size) return null;\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null) return null;\n  if ((lenB & 0x80) == 0x80) {\n    lenB &= 0x7f;\n    if (lenB == 0) throw newInvalidAsn1Error('Indefinite length not supported');\n    if (lenB > 4) throw newInvalidAsn1Error('encoding too long');\n    if (this._size - offset < lenB) return null;\n    this._len = 0;\n    for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n  return offset;\n};\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null) return null;\n  if (tag !== undefined && tag !== seq) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null) return null;\n  this._offset = o;\n  return seq;\n};\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\nReader.prototype.readBoolean = function () {\n  return this._readTag(ASN1.Boolean) === 0 ? false : true;\n};\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag) tag = ASN1.OctetString;\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  if (this.length === 0) return '';\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n  return retbuf ? str : str.toString('utf8');\n};\nReader.prototype.readOID = function (tag) {\n  if (!tag) tag = ASN1.OID;\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null) return null;\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  var values = [];\n  var value = 0;\n  for (var i = 0; i < this.length; i++) {\n    var byte = this._buf[this._offset++] & 0xff;\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) == 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift(value / 40 >> 0);\n  return values.join('.');\n};\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null) return null;\n  if (this.length > 4) throw newInvalidAsn1Error('Integer too long: ' + this.length);\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  var fb = this._buf[this._offset++];\n  var value = 0;\n  value = fb & 0x7F;\n  for (var i = 1; i < this.length; i++) {\n    value <<= 8;\n    value |= this._buf[this._offset++] & 0xff;\n  }\n  if ((fb & 0x80) == 0x80) value = -value;\n  return value;\n};\n\n///--- Exported API\n\nmodule.exports = Reader;","map":{"version":3,"names":["assert","require","ASN1","errors","newInvalidAsn1Error","Reader","data","Buffer","isBuffer","TypeError","_buf","_size","length","_len","_offset","self","__defineGetter__","slice","prototype","readByte","peek","b","readLength","offset","undefined","lenB","i","readSequence","tag","seq","toString","o","readInt","_readTag","Integer","readBoolean","Boolean","readEnumeration","Enumeration","readString","retbuf","OctetString","str","readOID","OID","values","value","byte","push","shift","unshift","join","ok","fb","module","exports"],"sources":["/Users/jaraga/CodeOp/perthesclinica/node_modules/asn1/lib/ber/reader.js"],"sourcesContent":["// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n///--- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n///--- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n\n  var self = this;\n  this.__defineGetter__('length', function() { return self._len; });\n  this.__defineGetter__('offset', function() { return self._offset; });\n  this.__defineGetter__('remain', function() {\n    return self._size - self._offset;\n  });\n  this.__defineGetter__('buffer', function() {\n    return self._buf.slice(self._offset);\n  });\n}\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function(peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function() {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function(offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) == 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB == 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function(tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function() {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function() {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function() {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function(tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function(tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    var byte = this._buf[this._offset++] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) == 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function(tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset++];\n  var value = 0;\n\n  value = fb & 0x7F;\n  for (var i = 1; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) == 0x80)\n    value = -value;\n\n  return value;\n};\n\n\n\n///--- Exported API\n\nmodule.exports = Reader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}