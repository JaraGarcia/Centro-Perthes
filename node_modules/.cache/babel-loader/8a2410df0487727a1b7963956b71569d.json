{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\nfunction TransformState(options, stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data !== null && data !== undefined) stream.push(data);\n  if (cb) cb(er);\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  this.once('finish', function () {\n    if ('function' === typeof this._flush) this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n  if (ws.length) throw new Error('calling transform done when ws.length != 0');\n  if (ts.transforming) throw new Error('calling transform done when still transforming');\n  return stream.push(null);\n}","map":{"version":3,"names":["module","exports","Transform","Duplex","require","util","inherits","TransformState","options","stream","afterTransform","er","data","needTransform","transforming","writecb","writechunk","ts","_transformState","cb","emit","Error","undefined","push","rs","_readableState","reading","needReadable","length","highWaterMark","_read","call","sync","once","_flush","done","prototype","chunk","encoding","_transform","_write","writeencoding","n","ws","_writableState"],"sources":["/Users/jaraga/CodeOp/perthesclinica/node_modules/stream-wrapper/node_modules/readable-stream/lib/_stream_transform.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}