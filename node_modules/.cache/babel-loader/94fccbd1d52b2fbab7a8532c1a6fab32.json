{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\n\nvar mod_ctf = require('./ctf.js');\nvar mod_ctio = require('./ctio.js');\nvar mod_assert = require('assert');\n\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\nvar deftypes = {\n  'uint8_t': {\n    read: ctReadUint8,\n    write: ctWriteUint8\n  },\n  'uint16_t': {\n    read: ctReadUint16,\n    write: ctWriteUint16\n  },\n  'uint32_t': {\n    read: ctReadUint32,\n    write: ctWriteUint32\n  },\n  'uint64_t': {\n    read: ctReadUint64,\n    write: ctWriteUint64\n  },\n  'int8_t': {\n    read: ctReadSint8,\n    write: ctWriteSint8\n  },\n  'int16_t': {\n    read: ctReadSint16,\n    write: ctWriteSint16\n  },\n  'int32_t': {\n    read: ctReadSint32,\n    write: ctWriteSint32\n  },\n  'int64_t': {\n    read: ctReadSint64,\n    write: ctWriteSint64\n  },\n  'float': {\n    read: ctReadFloat,\n    write: ctWriteFloat\n  },\n  'double': {\n    read: ctReadDouble,\n    write: ctWriteDouble\n  },\n  'char': {\n    read: ctReadChar,\n    write: ctWriteChar\n  },\n  'char[]': {\n    read: ctReadCharArray,\n    write: ctWriteCharArray\n  }\n};\n\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\nfunction ctReadUint8(endian, buffer, offset) {\n  var val = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\nfunction ctReadUint16(endian, buffer, offset) {\n  var val = mod_ctio.ruint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\nfunction ctReadUint32(endian, buffer, offset) {\n  var val = mod_ctio.ruint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\nfunction ctReadUint64(endian, buffer, offset) {\n  var val = mod_ctio.ruint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\nfunction ctReadSint8(endian, buffer, offset) {\n  var val = mod_ctio.rsint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\nfunction ctReadSint16(endian, buffer, offset) {\n  var val = mod_ctio.rsint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\nfunction ctReadSint32(endian, buffer, offset) {\n  var val = mod_ctio.rsint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\nfunction ctReadSint64(endian, buffer, offset) {\n  var val = mod_ctio.rsint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\nfunction ctReadFloat(endian, buffer, offset) {\n  var val = mod_ctio.rfloat(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\nfunction ctReadDouble(endian, buffer, offset) {\n  var val = mod_ctio.rdouble(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n\n/*\n * Reads a single character into a node buffer\n */\nfunction ctReadChar(endian, buffer, offset) {\n  var res = new Buffer(1);\n  res[0] = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: res,\n    size: 1\n  };\n}\nfunction ctReadCharArray(length, endian, buffer, offset) {\n  var ii;\n  var res = new Buffer(length);\n  for (ii = 0; ii < length; ii++) res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n  return {\n    value: res,\n    size: length\n  };\n}\nfunction ctWriteUint8(value, endian, buffer, offset) {\n  mod_ctio.wuint8(value, endian, buffer, offset);\n  return 1;\n}\nfunction ctWriteUint16(value, endian, buffer, offset) {\n  mod_ctio.wuint16(value, endian, buffer, offset);\n  return 2;\n}\nfunction ctWriteUint32(value, endian, buffer, offset) {\n  mod_ctio.wuint32(value, endian, buffer, offset);\n  return 4;\n}\nfunction ctWriteUint64(value, endian, buffer, offset) {\n  mod_ctio.wuint64(value, endian, buffer, offset);\n  return 8;\n}\nfunction ctWriteSint8(value, endian, buffer, offset) {\n  mod_ctio.wsint8(value, endian, buffer, offset);\n  return 1;\n}\nfunction ctWriteSint16(value, endian, buffer, offset) {\n  mod_ctio.wsint16(value, endian, buffer, offset);\n  return 2;\n}\nfunction ctWriteSint32(value, endian, buffer, offset) {\n  mod_ctio.wsint32(value, endian, buffer, offset);\n  return 4;\n}\nfunction ctWriteSint64(value, endian, buffer, offset) {\n  mod_ctio.wsint64(value, endian, buffer, offset);\n  return 8;\n}\nfunction ctWriteFloat(value, endian, buffer, offset) {\n  mod_ctio.wfloat(value, endian, buffer, offset);\n  return 4;\n}\nfunction ctWriteDouble(value, endian, buffer, offset) {\n  mod_ctio.wdouble(value, endian, buffer, offset);\n  return 8;\n}\n\n/*\n * Writes a single character into a node buffer\n */\nfunction ctWriteChar(value, endian, buffer, offset) {\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  mod_ctio.ruint8(value[0], endian, buffer, offset);\n  return 1;\n}\n\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\nfunction ctWriteCharArray(value, length, endian, buffer, offset) {\n  var ii;\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  if (value.length > length) throw new Error('value length greater than array length');\n  for (ii = 0; ii < value.length && ii < length; ii++) mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n  for (; ii < length; ii++) mod_ctio.wuint8(0, endian, offset + ii);\n  return length;\n}\n\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\nfunction ctGetBasicTypes() {\n  var ret = {};\n  var key;\n  for (key in deftypes) ret[key] = deftypes[key];\n  return ret;\n}\n\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\nfunction ctParseType(str) {\n  var begInd, endInd;\n  var type, len;\n  if (typeof str != 'string') throw new Error('type must be a Javascript string');\n  endInd = str.lastIndexOf(']');\n  if (endInd == -1) {\n    if (str.lastIndexOf('[') != -1) throw new Error('found invalid type with \\'[\\' but ' + 'no corresponding \\']\\'');\n    return {\n      type: str\n    };\n  }\n  begInd = str.lastIndexOf('[');\n  if (begInd == -1) throw new Error('found invalid type with \\']\\' but ' + 'no corresponding \\'[\\'');\n  if (begInd >= endInd) throw new Error('malformed type, \\']\\' appears before \\'[\\'');\n  type = str.substring(0, begInd);\n  len = str.substring(begInd + 1, endInd);\n  return {\n    type: type,\n    len: len\n  };\n}\n\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\nfunction ctCheckReq(def, types, fields) {\n  var ii, jj;\n  var req, keys, key;\n  var found = {};\n  if (!(def instanceof Array)) throw new Error('definition is not an array');\n  if (def.length === 0) throw new Error('definition must have at least one element');\n  for (ii = 0; ii < def.length; ii++) {\n    req = def[ii];\n    if (!(req instanceof Object)) throw new Error('definition must be an array of' + 'objects');\n    keys = Object.keys(req);\n    if (keys.length != 1) throw new Error('definition entry must only have ' + 'one key');\n    if (keys[0] in found) throw new Error('Specified name already ' + 'specified: ' + keys[0]);\n    if (!('type' in req[keys[0]])) throw new Error('missing required type definition');\n    key = ctParseType(req[keys[0]]['type']);\n\n    /*\n     * We may have nested arrays, we need to check the validity of\n     * the types until the len field is undefined in key. However,\n     * each time len is defined we need to verify it is either an\n     * integer or corresponds to an already seen key.\n     */\n    while (key['len'] !== undefined) {\n      if (isNaN(parseInt(key['len'], 10))) {\n        if (!(key['len'] in found)) throw new Error('Given an array ' + 'length without a matching type');\n      }\n      key = ctParseType(key['type']);\n    }\n\n    /* Now we can validate if the type is valid */\n    if (!(key['type'] in types)) throw new Error('type not found or typdefed: ' + key['type']);\n\n    /* Check for any required fields */\n    if (fields !== undefined) {\n      for (jj = 0; jj < fields.length; jj++) {\n        if (!(fields[jj] in req[keys[0]])) throw new Error('Missing required ' + 'field: ' + fields[jj]);\n      }\n    }\n    found[keys[0]] = true;\n  }\n}\n\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\nfunction CTypeParser(conf) {\n  if (!conf) throw new Error('missing required argument');\n  if (!('endian' in conf)) throw new Error('missing required endian value');\n  if (conf['endian'] != 'big' && conf['endian'] != 'little') throw new Error('Invalid endian type');\n  if ('char-type' in conf && conf['char-type'] != 'uint8' && conf['char-type'] != 'int8') throw new Error('invalid option for char-type: ' + conf['char-type']);\n  this.endian = conf['endian'];\n  this.types = ctGetBasicTypes();\n\n  /*\n   * There may be a more graceful way to do this, but this will have to\n   * serve.\n   */\n  if ('char-type' in conf && conf['char-type'] == 'uint8') this.types['char'] = this.types['uint8_t'];\n  if ('char-type' in conf && conf['char-type'] == 'int8') this.types['char'] = this.types['int8_t'];\n}\n\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\nCTypeParser.prototype.setEndian = function (endian) {\n  if (endian != 'big' && endian != 'little') throw new Error('invalid endian type, must be big or ' + 'little');\n  this.endian = endian;\n};\n\n/*\n * Returns the current value of the endian value for the parser.\n */\nCTypeParser.prototype.getEndian = function () {\n  return this.endian;\n};\n\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\nCTypeParser.prototype.typedef = function (name, value) {\n  var type;\n  if (name === undefined) throw new (Error('missing required typedef argument: name'))();\n  if (value === undefined) throw new (Error('missing required typedef argument: value'))();\n  if (typeof name != 'string') throw new (Error('the name of a type must be a string'))();\n  type = ctParseType(name);\n  if (type['len'] !== undefined) throw new Error('Cannot have an array in the typedef name');\n  if (name in this.types) throw new Error('typedef name already present: ' + name);\n  if (typeof value != 'string' && !(value instanceof Array)) throw new Error('typedef value must either be a string or ' + 'struct');\n  if (typeof value == 'string') {\n    type = ctParseType(value);\n    if (type['len'] !== undefined) {\n      if (isNaN(parseInt(type['len'], 10))) throw new (Error('typedef value must use ' + 'fixed size array when outside of a ' + 'struct'))();\n    }\n    this.types[name] = value;\n  } else {\n    /* We have a struct, validate it */\n    ctCheckReq(value, this.types);\n    this.types[name] = value;\n  }\n};\n\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\nCTypeParser.prototype.lstypes = function () {\n  var key;\n  var ret = {};\n  for (key in this.types) {\n    if (key in deftypes) continue;\n    ret[key] = this.types[key];\n  }\n  return ret;\n};\n\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\nfunction ctResolveArray(str, values) {\n  var ret = '';\n  var type = ctParseType(str);\n  while (type['len'] !== undefined) {\n    if (isNaN(parseInt(type['len'], 10))) {\n      if (typeof values[type['len']] != 'number') throw new Error('cannot sawp in non-number ' + 'for array value');\n      ret = '[' + values[type['len']] + ']' + ret;\n    } else {\n      ret = '[' + type['len'] + ']' + ret;\n    }\n    type = ctParseType(type['type']);\n  }\n  ret = type['type'] + ret;\n  return ret;\n}\n\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer, offset, value) {\n  var pt;\n  mod_assert.ok(type in this.types);\n  if (typeof this.types[type] == 'string') {\n    pt = ctParseType(this.types[type]);\n    if (dispatch == 'read') return this.readEntry(pt, buffer, offset);else if (dispatch == 'write') return this.writeEntry(value, pt, buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  } else {\n    if (dispatch == 'read') return this.readStruct(this.types[type], buffer, offset);else if (dispatch == 'write') return this.writeStruct(value, this.types[type], buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  }\n};\n\n/*\n * [private] Try and read in the specific entry.\n */\nCTypeParser.prototype.readEntry = function (type, buffer, offset) {\n  var parse, len;\n\n  /*\n   * Because we want to special case char[]s this is unfortunately\n   * a bit uglier than it really should be. We want to special\n   * case char[]s so that we return a node buffer, thus they are a\n   * first class type where as all other arrays just call into a\n   * generic array routine which calls their data-specific routine\n   * the specified number of times.\n   *\n   * The valid dispatch options we have are:\n   *  - Array and char => char[] handler\n   *  - Generic array handler\n   *  - Generic typedef handler\n   *  - Basic type handler\n   */\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') parse = this.types['char[]']['read'](len, this.endian, buffer, offset);else parse = this.readArray(type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) parse = this.types[type['type']]['read'](this.endian, buffer, offset);else parse = this.resolveTypedef(type['type'], 'read', buffer, offset);\n  }\n  return parse;\n};\n\n/*\n * [private] Read an array of data\n */\nCTypeParser.prototype.readArray = function (type, length, buffer, offset) {\n  var ii, ent, pt;\n  var baseOffset = offset;\n  var ret = new Array(length);\n  pt = ctParseType(type);\n  for (ii = 0; ii < length; ii++) {\n    ent = this.readEntry(pt, buffer, offset);\n    offset += ent['size'];\n    ret[ii] = ent['value'];\n  }\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n\n/*\n * [private] Read a single struct in.\n */\nCTypeParser.prototype.readStruct = function (def, buffer, offset) {\n  var parse, ii, type, entry, key;\n  var baseOffset = offset;\n  var ret = {};\n\n  /* Walk it and handle doing what's necessary */\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n\n    /* Resolve all array values */\n    type = ctParseType(ctResolveArray(entry['type'], ret));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    parse = this.readEntry(type, buffer, offset);\n    offset += parse['size'];\n    ret[key] = parse['value'];\n  }\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\nCTypeParser.prototype.readData = function (def, buffer, offset) {\n  /* Sanity check for arguments */\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n\n  /* Sanity check the object definition */\n  ctCheckReq(def, this.types);\n  return this.readStruct(def, buffer, offset)['value'];\n};\n\n/*\n * [private] Write out an array of data\n */\nCTypeParser.prototype.writeArray = function (value, type, length, buffer, offset) {\n  var ii, pt;\n  var baseOffset = offset;\n  if (!(value instanceof Array)) throw new Error('asked to write an array, but value is not ' + 'an array');\n  if (value.length != length) throw new Error('asked to write array of length ' + length + ' but that does not match value length: ' + value.length);\n  pt = ctParseType(type);\n  for (ii = 0; ii < length; ii++) offset += this.writeEntry(value[ii], pt, buffer, offset);\n  return offset - baseOffset;\n};\n\n/*\n * [private] Write the specific entry\n */\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset) {\n  var len, ret;\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') ret = this.types['char[]']['write'](value, len, this.endian, buffer, offset);else ret = this.writeArray(value, type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) ret = this.types[type['type']]['write'](value, this.endian, buffer, offset);else ret = this.resolveTypedef(type['type'], 'write', buffer, offset, value);\n  }\n  return ret;\n};\n\n/*\n * [private] Write a single struct out.\n */\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset) {\n  var ii, entry, type, key;\n  var baseOffset = offset;\n  var vals = {};\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n    type = ctParseType(ctResolveArray(entry['type'], vals));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    offset += this.writeEntry(value[ii], type, buffer, offset);\n    /* Now that we've written it out, we can use it for arrays */\n    vals[key] = value[ii];\n  }\n  return offset;\n};\n\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\nfunction getValues(def) {\n  var ii, out, key;\n  out = [];\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    mod_assert.ok('value' in def[ii][key]);\n    out.push(def[ii][key]['value']);\n  }\n  return out;\n}\n\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\nCTypeParser.prototype.writeData = function (def, buffer, offset, values) {\n  var hv;\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n  hv = values != null && values != undefined;\n  if (hv) {\n    if (!Array.isArray(values)) throw new Error('missing values for writing');\n    ctCheckReq(def, this.types);\n  } else {\n    ctCheckReq(def, this.types, ['value']);\n  }\n  this.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toAbs64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n\n  /* We have 20 bits worth of precision in this range */\n  if (val[0] >= 0x100000) throw new Error('value would become approximated');\n  return val[0] * Math.pow(2, 32) + val[1];\n}\n\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toApprox64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n  return Math.pow(2, 32) * val[0] + val[1];\n}\nfunction parseCTF(json, conf) {\n  var ctype = new CTypeParser(conf);\n  mod_ctf.ctfParseJson(json, ctype);\n  return ctype;\n}\n\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\nexports.parseCTF = parseCTF;\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;","map":{"version":3,"names":["mod_ctf","require","mod_ctio","mod_assert","deftypes","read","ctReadUint8","write","ctWriteUint8","ctReadUint16","ctWriteUint16","ctReadUint32","ctWriteUint32","ctReadUint64","ctWriteUint64","ctReadSint8","ctWriteSint8","ctReadSint16","ctWriteSint16","ctReadSint32","ctWriteSint32","ctReadSint64","ctWriteSint64","ctReadFloat","ctWriteFloat","ctReadDouble","ctWriteDouble","ctReadChar","ctWriteChar","ctReadCharArray","ctWriteCharArray","endian","buffer","offset","val","ruint8","value","size","ruint16","ruint32","ruint64","rsint8","rsint16","rsint32","rsint64","rfloat","rdouble","res","Buffer","length","ii","wuint8","wuint16","wuint32","wuint64","wsint8","wsint16","wsint32","wsint64","wfloat","wdouble","Error","ctGetBasicTypes","ret","key","ctParseType","str","begInd","endInd","type","len","lastIndexOf","substring","ctCheckReq","def","types","fields","jj","req","keys","found","Array","Object","undefined","isNaN","parseInt","CTypeParser","conf","prototype","setEndian","getEndian","typedef","name","lstypes","ctResolveArray","values","resolveTypedef","dispatch","pt","ok","readEntry","writeEntry","readStruct","writeStruct","parse","readArray","ent","baseOffset","entry","readData","writeArray","vals","getValues","out","push","writeData","hv","isArray","toAbs64","Math","pow","toApprox64","parseCTF","json","ctype","ctfParseJson","exports","Parser"],"sources":["/Users/jaraga/CodeOp/perthesclinica/node_modules/ctype/ctype.js"],"sourcesContent":["/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\n\nvar mod_ctf = require('./ctf.js');\nvar mod_ctio = require('./ctio.js');\nvar mod_assert = require('assert');\n\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\nvar deftypes = {\n    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },\n    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },\n    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },\n    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },\n    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },\n    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },\n    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },\n    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },\n    'float': { read: ctReadFloat, write: ctWriteFloat },\n    'double': { read: ctReadDouble, write: ctWriteDouble },\n    'char': { read: ctReadChar, write: ctWriteChar },\n    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }\n};\n\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\nfunction ctReadUint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadUint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadUint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadUint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadSint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadSint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadSint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadSint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadFloat(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rfloat(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadDouble(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rdouble(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\n/*\n * Reads a single character into a node buffer\n */\nfunction ctReadChar(endian, buffer, offset)\n{\n\tvar res = new Buffer(1);\n\tres[0] = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: res, size: 1 });\n}\n\nfunction ctReadCharArray(length, endian, buffer, offset)\n{\n\tvar ii;\n\tvar res = new Buffer(length);\n\n\tfor (ii = 0; ii < length; ii++)\n\t\tres[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n\n\treturn ({ value: res, size: length });\n}\n\nfunction ctWriteUint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteUint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteUint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteUint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteSint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteSint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteSint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteSint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteFloat(value, endian, buffer, offset)\n{\n\tmod_ctio.wfloat(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteDouble(value, endian, buffer, offset)\n{\n\tmod_ctio.wdouble(value, endian, buffer, offset);\n\treturn (8);\n}\n\n/*\n * Writes a single character into a node buffer\n */\nfunction ctWriteChar(value, endian, buffer, offset)\n{\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tmod_ctio.ruint8(value[0], endian, buffer, offset);\n\treturn (1);\n}\n\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\nfunction ctWriteCharArray(value, length, endian, buffer, offset)\n{\n\tvar ii;\n\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tif (value.length > length)\n\t\tthrow (new Error('value length greater than array length'));\n\n\tfor (ii = 0; ii < value.length && ii < length; ii++)\n\t\tmod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n\n\tfor (; ii < length; ii++)\n\t\tmod_ctio.wuint8(0, endian, offset + ii);\n\n\n\treturn (length);\n}\n\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\nfunction ctGetBasicTypes()\n{\n\tvar ret = {};\n\tvar key;\n\tfor (key in deftypes)\n\t\tret[key] = deftypes[key];\n\n\treturn (ret);\n}\n\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\nfunction ctParseType(str)\n{\n\tvar begInd, endInd;\n\tvar type, len;\n\tif (typeof (str) != 'string')\n\t\tthrow (new Error('type must be a Javascript string'));\n\n\tendInd = str.lastIndexOf(']');\n\tif (endInd == -1) {\n\t\tif (str.lastIndexOf('[') != -1)\n\t\t\tthrow (new Error('found invalid type with \\'[\\' but ' +\n\t\t\t    'no corresponding \\']\\''));\n\n\t\treturn ({ type: str });\n\t}\n\n\tbegInd = str.lastIndexOf('[');\n\tif (begInd == -1)\n\t\tthrow (new Error('found invalid type with \\']\\' but ' +\n\t\t    'no corresponding \\'[\\''));\n\n\tif (begInd >= endInd)\n\t\tthrow (new Error('malformed type, \\']\\' appears before \\'[\\''));\n\n\ttype = str.substring(0, begInd);\n\tlen = str.substring(begInd + 1, endInd);\n\n\treturn ({ type: type, len: len });\n}\n\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\nfunction ctCheckReq(def, types, fields)\n{\n\tvar ii, jj;\n\tvar req, keys, key;\n\tvar found = {};\n\n\tif (!(def instanceof Array))\n\t\tthrow (new Error('definition is not an array'));\n\n\tif (def.length === 0)\n\t\tthrow (new Error('definition must have at least one element'));\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\treq = def[ii];\n\t\tif (!(req instanceof Object))\n\t\t\tthrow (new Error('definition must be an array of' +\n\t\t\t    'objects'));\n\n\t\tkeys = Object.keys(req);\n\t\tif (keys.length != 1)\n\t\t\tthrow (new Error('definition entry must only have ' +\n\t\t\t    'one key'));\n\n\t\tif (keys[0] in found)\n\t\t\tthrow (new Error('Specified name already ' +\n\t\t\t    'specified: ' + keys[0]));\n\n\t\tif (!('type' in req[keys[0]]))\n\t\t\tthrow (new Error('missing required type definition'));\n\n\t\tkey = ctParseType(req[keys[0]]['type']);\n\n\t\t/*\n\t\t * We may have nested arrays, we need to check the validity of\n\t\t * the types until the len field is undefined in key. However,\n\t\t * each time len is defined we need to verify it is either an\n\t\t * integer or corresponds to an already seen key.\n\t\t */\n\t\twhile (key['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(key['len'], 10))) {\n\t\t\t\tif (!(key['len'] in found))\n\t\t\t\t\tthrow (new Error('Given an array ' +\n\t\t\t\t\t    'length without a matching type'));\n\n\t\t\t}\n\n\t\t\tkey = ctParseType(key['type']);\n\t\t}\n\n\t\t/* Now we can validate if the type is valid */\n\t\tif (!(key['type'] in types))\n\t\t\tthrow (new Error('type not found or typdefed: ' +\n\t\t\t    key['type']));\n\n\t\t/* Check for any required fields */\n\t\tif (fields !== undefined) {\n\t\t\tfor (jj = 0; jj < fields.length; jj++) {\n\t\t\t\tif (!(fields[jj] in req[keys[0]]))\n\t\t\t\t\tthrow (new Error('Missing required ' +\n\t\t\t\t\t    'field: ' + fields[jj]));\n\t\t\t}\n\t\t}\n\n\t\tfound[keys[0]] = true;\n\t}\n}\n\n\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\nfunction CTypeParser(conf)\n{\n\tif (!conf) throw (new Error('missing required argument'));\n\n\tif (!('endian' in conf))\n\t\tthrow (new Error('missing required endian value'));\n\n\tif (conf['endian'] != 'big' && conf['endian'] != 'little')\n\t\tthrow (new Error('Invalid endian type'));\n\n\tif ('char-type' in conf && (conf['char-type'] != 'uint8' &&\n\t    conf['char-type'] != 'int8'))\n\t\tthrow (new Error('invalid option for char-type: ' +\n\t\t    conf['char-type']));\n\n\tthis.endian = conf['endian'];\n\tthis.types = ctGetBasicTypes();\n\n\t/*\n\t * There may be a more graceful way to do this, but this will have to\n\t * serve.\n\t */\n\tif ('char-type' in conf && conf['char-type'] == 'uint8')\n\t\tthis.types['char'] = this.types['uint8_t'];\n\n\tif ('char-type' in conf && conf['char-type'] == 'int8')\n\t\tthis.types['char'] = this.types['int8_t'];\n}\n\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\nCTypeParser.prototype.setEndian = function (endian)\n{\n\tif (endian != 'big' && endian != 'little')\n\t\tthrow (new Error('invalid endian type, must be big or ' +\n\t\t    'little'));\n\n\tthis.endian = endian;\n};\n\n/*\n * Returns the current value of the endian value for the parser.\n */\nCTypeParser.prototype.getEndian = function ()\n{\n\treturn (this.endian);\n};\n\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\nCTypeParser.prototype.typedef = function (name, value)\n{\n\tvar type;\n\n\tif (name === undefined)\n\t\tthrow (new (Error('missing required typedef argument: name')));\n\n\tif (value === undefined)\n\t\tthrow (new (Error('missing required typedef argument: value')));\n\n\tif (typeof (name) != 'string')\n\t\tthrow (new (Error('the name of a type must be a string')));\n\n\ttype = ctParseType(name);\n\n\tif (type['len'] !== undefined)\n\t\tthrow (new Error('Cannot have an array in the typedef name'));\n\n\tif (name in this.types)\n\t\tthrow (new Error('typedef name already present: ' + name));\n\n\tif (typeof (value) != 'string' && !(value instanceof Array))\n\t\tthrow (new Error('typedef value must either be a string or ' +\n\t\t    'struct'));\n\n\tif (typeof (value) == 'string') {\n\t\ttype = ctParseType(value);\n\t\tif (type['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(type['len'], 10)))\n\t\t\t\tthrow (new (Error('typedef value must use ' +\n\t\t\t\t    'fixed size array when outside of a ' +\n\t\t\t\t    'struct')));\n\t\t}\n\n\t\tthis.types[name] = value;\n\t} else {\n\t\t/* We have a struct, validate it */\n\t\tctCheckReq(value, this.types);\n\t\tthis.types[name] = value;\n\t}\n};\n\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\nCTypeParser.prototype.lstypes = function ()\n{\n\tvar key;\n\tvar ret = {};\n\n\tfor (key in this.types) {\n\t\tif (key in deftypes)\n\t\t\tcontinue;\n\t\tret[key] = this.types[key];\n\t}\n\n\treturn (ret);\n};\n\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\nfunction ctResolveArray(str, values)\n{\n\tvar ret = '';\n\tvar type = ctParseType(str);\n\n\twhile (type['len'] !== undefined) {\n\t\tif (isNaN(parseInt(type['len'], 10))) {\n\t\t\tif (typeof (values[type['len']]) != 'number')\n\t\t\t\tthrow (new Error('cannot sawp in non-number ' +\n\t\t\t\t    'for array value'));\n\t\t\tret = '[' + values[type['len']] + ']' + ret;\n\t\t} else {\n\t\t\tret = '[' + type['len'] + ']' + ret;\n\t\t}\n\t\ttype = ctParseType(type['type']);\n\t}\n\n\tret = type['type'] + ret;\n\n\treturn (ret);\n}\n\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,\n    offset, value)\n{\n\tvar pt;\n\n\tmod_assert.ok(type in this.types);\n\tif (typeof (this.types[type]) == 'string') {\n\t\tpt = ctParseType(this.types[type]);\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readEntry(pt, buffer, offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeEntry(value, pt, buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t} else {\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readStruct(this.types[type], buffer,\n\t\t\t    offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeStruct(value, this.types[type],\n\t\t\t    buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t}\n\n};\n\n/*\n * [private] Try and read in the specific entry.\n */\nCTypeParser.prototype.readEntry = function (type, buffer, offset)\n{\n\tvar parse, len;\n\n\t/*\n\t * Because we want to special case char[]s this is unfortunately\n\t * a bit uglier than it really should be. We want to special\n\t * case char[]s so that we return a node buffer, thus they are a\n\t * first class type where as all other arrays just call into a\n\t * generic array routine which calls their data-specific routine\n\t * the specified number of times.\n\t *\n\t * The valid dispatch options we have are:\n\t *  - Array and char => char[] handler\n\t *  - Generic array handler\n\t *  - Generic typedef handler\n\t *  - Basic type handler\n\t */\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tparse = this.types['char[]']['read'](len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tparse = this.readArray(type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tparse = this.types[type['type']]['read'](this.endian,\n\t\t\t    buffer, offset);\n\t\telse\n\t\t\tparse = this.resolveTypedef(type['type'], 'read',\n\t\t\t    buffer, offset);\n\t}\n\n\treturn (parse);\n};\n\n/*\n * [private] Read an array of data\n */\nCTypeParser.prototype.readArray = function (type, length, buffer, offset)\n{\n\tvar ii, ent, pt;\n\tvar baseOffset = offset;\n\tvar ret = new Array(length);\n\tpt = ctParseType(type);\n\n\tfor (ii = 0; ii < length; ii++) {\n\t\tent = this.readEntry(pt, buffer, offset);\n\t\toffset += ent['size'];\n\t\tret[ii] = ent['value'];\n\t}\n\n\treturn ({ value: ret, size: offset - baseOffset });\n};\n\n/*\n * [private] Read a single struct in.\n */\nCTypeParser.prototype.readStruct = function (def, buffer, offset)\n{\n\tvar parse, ii, type, entry, key;\n\tvar baseOffset = offset;\n\tvar ret = {};\n\n\t/* Walk it and handle doing what's necessary */\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\t/* Resolve all array values */\n\t\ttype = ctParseType(ctResolveArray(entry['type'], ret));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\tparse = this.readEntry(type, buffer, offset);\n\n\t\toffset += parse['size'];\n\t\tret[key] = parse['value'];\n\t}\n\n\treturn ({ value: ret, size: (offset-baseOffset)});\n};\n\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\nCTypeParser.prototype.readData = function (def, buffer, offset)\n{\n\t/* Sanity check for arguments */\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\t/* Sanity check the object definition */\n\tctCheckReq(def, this.types);\n\n\treturn (this.readStruct(def, buffer, offset)['value']);\n};\n\n/*\n * [private] Write out an array of data\n */\nCTypeParser.prototype.writeArray = function (value, type, length, buffer,\n    offset)\n{\n\tvar ii, pt;\n\tvar baseOffset = offset;\n\tif (!(value instanceof Array))\n\t\tthrow (new Error('asked to write an array, but value is not ' +\n\t\t    'an array'));\n\n\tif (value.length != length)\n\t\tthrow (new Error('asked to write array of length ' + length +\n\t\t    ' but that does not match value length: ' + value.length));\n\n\tpt = ctParseType(type);\n\tfor (ii = 0; ii < length; ii++)\n\t\toffset += this.writeEntry(value[ii], pt, buffer, offset);\n\n\treturn (offset - baseOffset);\n};\n\n/*\n * [private] Write the specific entry\n */\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset)\n{\n\tvar len, ret;\n\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tret = this.types['char[]']['write'](value, len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.writeArray(value, type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tret = this.types[type['type']]['write'](value,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.resolveTypedef(type['type'], 'write',\n\t\t\t    buffer, offset, value);\n\t}\n\n\treturn (ret);\n};\n\n/*\n * [private] Write a single struct out.\n */\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset)\n{\n\tvar ii, entry, type, key;\n\tvar baseOffset = offset;\n\tvar vals = {};\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\ttype = ctParseType(ctResolveArray(entry['type'], vals));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\toffset += this.writeEntry(value[ii], type, buffer, offset);\n\t\t/* Now that we've written it out, we can use it for arrays */\n\t\tvals[key] = value[ii];\n\t}\n\n\treturn (offset);\n};\n\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\nfunction getValues(def)\n{\n\tvar ii, out, key;\n\tout = [];\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tmod_assert.ok('value' in def[ii][key]);\n\t\tout.push(def[ii][key]['value']);\n\t}\n\n\treturn (out);\n}\n\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\nCTypeParser.prototype.writeData = function (def, buffer, offset, values)\n{\n\tvar hv;\n\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\thv = (values != null && values != undefined);\n\tif (hv) {\n\t\tif (!Array.isArray(values))\n\t\t\tthrow (new Error('missing values for writing'));\n\t\tctCheckReq(def, this.types);\n\t} else {\n\t\tctCheckReq(def, this.types, [ 'value' ]);\n\t}\n\n\tthis.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toAbs64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\t/* We have 20 bits worth of precision in this range */\n\tif (val[0] >= 0x100000)\n\t\tthrow (new Error('value would become approximated'));\n\n\treturn (val[0] * Math.pow(2, 32) + val[1]);\n}\n\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toApprox64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\treturn (Math.pow(2, 32) * val[0] + val[1]);\n}\n\nfunction parseCTF(json, conf)\n{\n\tvar ctype = new CTypeParser(conf);\n\tmod_ctf.ctfParseJson(json, ctype);\n\n\treturn (ctype);\n}\n\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\n\nexports.parseCTF = parseCTF;\n\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\n\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\n\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}