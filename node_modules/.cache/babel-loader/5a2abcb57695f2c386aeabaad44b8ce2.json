{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\n///--- Globals\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\nvar State = {\n  New: 0,\n  Params: 1\n};\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3\n};\n\n///--- Specific Errors\n\nfunction HttpSignatureError(message, caller) {\n  if (Error.captureStackTrace) Error.captureStackTrace(this, caller || HttpSignatureError);\n  this.message = message;\n  this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\n///--- Exported API\n\nmodule.exports = {\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"content-md5\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalNumber(options.clockSkew, 'options.clockSkew');\n    if (!request.headers.authorization) throw new MissingHeaderError('no authorization header present in ' + 'the request');\n    options.clockSkew = options.clockSkew || 300;\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n    var parsed = {\n      scheme: '',\n      params: {},\n      signingString: '',\n      get algorithm() {\n        return this.params.algorithm.toUpperCase();\n      },\n      get keyId() {\n        return this.params.keyId;\n      }\n    };\n    var authz = request.headers.authorization;\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n      switch (Number(state)) {\n        case State.New:\n          if (c !== ' ') parsed.scheme += c;else state = State.Params;\n          break;\n        case State.Params:\n          switch (Number(substate)) {\n            case ParamsState.Name:\n              var code = c.charCodeAt(0);\n              // restricted name of A-Z / a-z\n              if (code >= 0x41 && code <= 0x5a ||\n              // A-Z\n              code >= 0x61 && code <= 0x7a) {\n                // a-z\n                tmpName += c;\n              } else if (c === '=') {\n                if (tmpName.length === 0) throw new InvalidHeaderError('bad param format');\n                substate = ParamsState.Quote;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n            case ParamsState.Quote:\n              if (c === '\"') {\n                tmpValue = '';\n                substate = ParamsState.Value;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n            case ParamsState.Value:\n              if (c === '\"') {\n                parsed.params[tmpName] = tmpValue;\n                substate = ParamsState.Comma;\n              } else {\n                tmpValue += c;\n              }\n              break;\n            case ParamsState.Comma:\n              if (c === ',') {\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                throw new InvalidHeaderError('bad param format');\n              }\n              break;\n            default:\n              throw new Error('Invalid substate');\n          }\n          break;\n        default:\n          throw new Error('Invalid substate');\n      }\n    }\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature') throw new InvalidHeaderError('scheme was not \"Signature\"');\n    if (!parsed.params.keyId) throw new InvalidHeaderError('keyId was not specified');\n    if (!parsed.params.algorithm) throw new InvalidHeaderError('algorithm was not specified');\n    if (!parsed.params.signature) throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (!Algorithms[parsed.params.algorithm]) throw new InvalidParamsError(parsed.params.algorithm + ' is not supported');\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n      if (h !== 'request-line') {\n        var value = request.headers[h];\n        if (!value) throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      } else {\n        parsed.signingString += request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n      }\n      if (i + 1 < parsed.params.headers.length) parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    if (request.headers.date || request.headers['x-date']) {\n      if (request.headers['x-date']) {\n        date = new Date(request.headers['x-date']);\n      } else {\n        date = new Date(request.headers.date);\n      }\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' + skew / 1000 + 's was greater than ' + options.clockSkew + 's');\n      }\n    }\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr) < 0) throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + ' is not a supported algorithm');\n    }\n    return parsed;\n  }\n};","map":{"version":3,"names":["assert","require","util","Algorithms","State","New","Params","ParamsState","Name","Quote","Value","Comma","HttpSignatureError","message","caller","Error","captureStackTrace","name","inherits","ExpiredRequestError","call","InvalidHeaderError","InvalidParamsError","MissingHeaderError","module","exports","parseRequest","request","options","object","headers","undefined","arrayOfString","optionalNumber","clockSkew","authorization","i","state","substate","tmpName","tmpValue","parsed","scheme","params","signingString","algorithm","toUpperCase","keyId","authz","length","c","charAt","Number","code","charCodeAt","split","signature","toLowerCase","h","value","method","url","httpVersion","date","Date","now","skew","Math","abs","getTime","forEach","hdr","indexOf","algorithms"],"sources":["/Users/jaraga/CodeOp/perthesclinica/node_modules/http-signature/lib/parser.js"],"sourcesContent":["// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\n\n\n///--- Globals\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\n\nvar State = {\n  New: 0,\n  Params: 1\n};\n\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3\n};\n\n\n\n///--- Specific Errors\n\nfunction HttpSignatureError(message, caller) {\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, caller || HttpSignatureError);\n\n  this.message = message;\n  this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\n\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"content-md5\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalNumber(options.clockSkew, 'options.clockSkew');\n\n    if (!request.headers.authorization)\n      throw new MissingHeaderError('no authorization header present in ' +\n                                   'the request');\n\n    options.clockSkew = options.clockSkew || 300;\n\n\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n\n    var parsed = {\n      scheme: '',\n      params: {},\n      signingString: '',\n\n      get algorithm() {\n        return this.params.algorithm.toUpperCase();\n      },\n\n      get keyId() {\n        return this.params.keyId;\n      }\n\n    };\n\n    var authz = request.headers.authorization;\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n\n      case State.New:\n        if (c !== ' ') parsed.scheme += c;\n        else state = State.Params;\n        break;\n\n      case State.Params:\n        switch (Number(substate)) {\n\n        case ParamsState.Name:\n          var code = c.charCodeAt(0);\n          // restricted name of A-Z / a-z\n          if ((code >= 0x41 && code <= 0x5a) || // A-Z\n              (code >= 0x61 && code <= 0x7a)) { // a-z\n            tmpName += c;\n          } else if (c === '=') {\n            if (tmpName.length === 0)\n              throw new InvalidHeaderError('bad param format');\n            substate = ParamsState.Quote;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Quote:\n          if (c === '\"') {\n            tmpValue = '';\n            substate = ParamsState.Value;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Value:\n          if (c === '\"') {\n            parsed.params[tmpName] = tmpValue;\n            substate = ParamsState.Comma;\n          } else {\n            tmpValue += c;\n          }\n          break;\n\n        case ParamsState.Comma:\n          if (c === ',') {\n            tmpName = '';\n            substate = ParamsState.Name;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n        }\n        break;\n\n      default:\n        throw new Error('Invalid substate');\n      }\n\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature')\n      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n    if (!parsed.params.keyId)\n      throw new InvalidHeaderError('keyId was not specified');\n\n    if (!parsed.params.algorithm)\n      throw new InvalidHeaderError('algorithm was not specified');\n\n    if (!parsed.params.signature)\n      throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (!Algorithms[parsed.params.algorithm])\n      throw new InvalidParamsError(parsed.params.algorithm +\n                                   ' is not supported');\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n\n      if (h !== 'request-line') {\n        var value = request.headers[h];\n        if (!value)\n          throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      } else {\n        parsed.signingString +=\n          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n      }\n\n      if ((i + 1) < parsed.params.headers.length)\n        parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    if (request.headers.date || request.headers['x-date']) {\n        if (request.headers['x-date']) {\n          date = new Date(request.headers['x-date']);\n        } else {\n          date = new Date(request.headers.date);\n        }\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' +\n                                      (skew / 1000) +\n                                      's was greater than ' +\n                                      options.clockSkew + 's');\n      }\n    }\n\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr) < 0)\n        throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n        throw new InvalidParamsError(parsed.params.algorithm +\n                                     ' is not a supported algorithm');\n    }\n\n    return parsed;\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}